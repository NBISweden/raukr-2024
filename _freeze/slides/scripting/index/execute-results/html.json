{
  "hash": "07facfb41a1c59f41ba8806a92e0029f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions and scripts\"\nauthor: \"Sebastian DiLorenzo\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n## {visibility=\"hidden\"}\n\n\n::: {.cell}\n\n:::\n\n\n## R Functions\n\n- Organised, human readable code\n- Any code that will be repeated\n- Add less objects to workspace\n- Perform a set task, preferably that task is not \"this whole analysis\"\n\n## R Functions\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n[**Without a function**]{style=\"background-color: #f2d7d5; padding: 5px;\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2\"}\na <- 5\na + a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- 3\nb + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n- User is performing the operation each time\n\n::: {.notes}\nAn R function is something you have probably used many times already.. Functions perform a set task within R. Lets looks at a quick example.\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n[**With a function**]{style=\"background-color: #d0ece7; padding: 5px;\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1-3|5-6|9\"}\ndoubleUp <- function(x){\n  x + x\n}\n\na <- 5\ndoubleUp(a)\nb <- 3\ndoubleUp(b)\nz <- doubleUp(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n[1] 6\n```\n\n\n:::\n:::\n\n\n- Function is performing the operation each time\n\n:::\n::::\n\n## R Functions\n\nThe pieces that make a function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(param1, param2 = 20, ...){\n  param1*2 # Operational space\n  param1+param2 # What is returned. Alt, use return(param1+param2)\n}\n```\n:::\n\n\n- `function_name` : Name of the function\n- `function()` : Parameters. User input\n  - `param1` : No default value. Required.\n  - `param2 = 20` : Default value\n  - `...`  : ellipses pass other arguments into function\n- `function(){}` : The function body\n- `return` : the last line or invoked with `return()` function.\n\n::: {.notes}\nA parameter is a variable in the declaration of the function.\nAn argument is the actual value of the variable that gets passed to the function.\n:::\n\n. . .\n\n::: {.callout-tip}\nHow to add a function to your workspace\n\n- copy paste\n- `source()` / `library()`\n:::\n\n## R scripts as standalone tools\n\n![](http://www.azquotes.com/picture-quotes/quote-this-is-the-unix-philosophy-write-programs-that-do-one-thing-and-do-it-well-write-programs-douglas-mcilroy-81-95-07.jpg)\n\n::: {.notes}\nIn many ways this quote about the UNIX philosophy relates to the philosophy you should have for an R script.\n\nMcIlroy is best known for having originally proposed Unix pipelines and developed several Unix tools, such as spell, diff, sort, join, graph, speak, and tr.\n:::\n\n. . .\n\n- Data analysis with R is usually performed interactively using e.g. RStudio\n- Tasks can be executed from the terminal using R scripts\n- R scripts can form powerful standalone tools\n\n::: {.notes}\nUsually when you are **analyzing data** you will use the **interactive view** and try different things going forward. But say that you have figured out something that you want to **do** for **multiple numbers** of datasets?\n\nAnd like the quote it should do **one** thing and do it well. Because of the **power** in that an **R script** can contain **multiple functions**, or \"programs\", this one thing can be quite **simple**, or quite **advanced**. And like the textstream mentioned here Rscripts often take input, something we will look more at now.\n\nIn this case it might be **efficient** to use an **Rscript**.\n\nSo USUALLY an rscript is something that is executable, can take some inputs and arguments, and returns something.\n\nNow lets look at those pieces starting with how an rscript can be executed.\n:::\n\n## Executing an R script\n\n- Interactively: `source(\"myscript.R\")` in R console \n\n::: {.notes}\nOne way to execute an Rscript is to use \"source myscript.R\" from an interactive session which **runs** whatever code is in the R script. So if it has **functions** or wether it **reads** a separate file and creates some new **object**, these will be in your **R environment** after sourcing the script.\n:::\n\n. . .\n\n- Command line: `Rscript myscript.R`\n\n::: {.notes}\nYou can also run the Rscript from the command line, or terminal. Then we use the command **Rscript**. It used to be not long ago that people used **R CMD batch**, but nowadays people usually use Rscript.\nLike the source, this will **execute** whichever code is in **myscript.R** but there is **no environment** for the **objects or functions** to pop into so the **code** in this Rscript is probably **different** than one that is intended for **source**.\n:::\n\n. . .\n\n- As executable file: `path/myscript.R` if:\n  - Script is executable: `chmod +x myscript.R`\n  - First line in script is a hashbang e.g. `#!/usr/bin/env Rscript`\n  - Script's path is included in call or `$PATH`\n\n::: {.notes}\nYou can also execute the Rscript **itself**, from terminal.\nTo execute an R script it must *meet three requirements*.\nIt must be **executable**.\nIt must start with this **special line**, specifying how it is executed if run on its own.\nIf you want to run it without giving path, its folder must be in you $PATH variable.\n:::\n\n## Providing arguments to an R script\n\n- Passing arguments to the script allows for flexibility in settings and input data\n\n::: {.notes}\n\n**Often** when we use an R script, like I mentioned in the **beginning**, we want to **pass multiple files/samples** through it for efficiency reasons. It **doesnt** just have to be **files**, like **functions** it can also be **argument settings.**\n\n:::\n\n. . .\n\n`./myscript.R inputfile.vcf outputfile.vcf`\n\n::: {.notes}\n\nHere for example we are using the Rscript as an **executable** file, giving it an **inputfile** and specifying what we want the **outputfile** to be named. Notice that the only way the R script knows what is what is positionally.\n:::\n\n. . .\n\n- Packages are available that support long and short flags\n\n`./myscript.R -i inputfile.vcf -o outputfile.vcf`\n\n::: {.notes}\n\n**Short flags** are when you give a single dash and usually a shortened version of the keyword, here *i for input* and *o for output* for example.\n:::\n\n. . .\n\n`./myscript.R --input inputfile.vcf --output outputfile.vcf`\n\n::: {.notes}\n\nAnd here **long flags** with *two dashes*\n:::\n\n. . .\n\n`./myscript.R --output inputfile.vcf --input outputfile.vcf`\n\n::: {.notes}\n\nA part of the **flexibility** of this is that you can give the flags in **any order**.\n:::\n\n. . .\n\n`./myscript.R --output inputfile.vcf -i inputfile.vcf`\n\n::: {.notes}\n\nAnd you can also *mix* the *long/short flag order and styles*. It is the coding in the script that determines how it handles this input.\n:::\n\n## Parsing arguments - Positional\n\nExample: `./myscript.R inputfile.vcf outputfile.vcf`\n\n\n- `commandArgs()`\n\nUse **commandArgs()** to capture whatever was **passed** into R as it was **executed**. To be **clear**; this is a command that is **within the Rscript file.**\n\n. . .\n\n- `trailingOnly = TRUE`\n\nAdd `trailingOnly = TRUE` to suppress the first few items and get the arguments **you** passed to the script.\n\n::: {.notes}\nA **standard arg**, but **not default**, that you can use when invoking `commandArgs()` is `trailingOnly = TRUE`, which basically tells it to start counting the input from **after** the **Rscript arguments**. As you can see here when we invoke it without this parameter it returns the script itself, in this case R studio. But with it the invocation is clear, there were no trailing command line arguments.\n:::\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncommandArgs()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/usr/local/lib/R/bin/exec/R\"        \"--no-save\"                         \n[3] \"--no-restore\"                       \"--no-echo\"                         \n[5] \"--no-restore\"                       \"--file=/opt/quarto/share/rmd/rmd.R\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncommandArgs(trailingOnly = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n## Parsing arguments - Flags\n\nExample: `./myscript.R --input inputfile.vcf --output outputfile.vcf`\n\n::: {.notes}\nSo how do we do it with **flags**?\n:::\n\n. . .\n\n- Several packages are available: `getopt`, `optparse`, `argparser`, ...\n\n. . .\n\nDefine set of possible arguments at start of script:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(optparse)\nmy_options = list(\n  make_option(c(\"-i\", \"--inputfile\"), default='variants.vcf'),\n  make_option(c(\"-o\", \"--outputfile\"), default='variants_filtered.vcf'))\n```\n:::\n\n\n::: {.notes}\nIf we use **optparse** as an example you **create** your options using the **make_option** command, and can set default values. We see also that you can give both long and short form here.\n:::\n\n. . .\n\nParse arguments using your definition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_args(OptionParser(option_list=my_options))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$inputfile\n[1] \"variants.vcf\"\n\n$outputfile\n[1] \"variants_filtered.vcf\"\n\n$help\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n::: {.notes}\nAnd then you use the **my_options** object we defined together with **parse_args and OptionParser** to **check our input** for those **flags** We also see an option, **help**, that we did not make, this is a **standard flag** that optparse always looks for and can generate what arguments it is looking for.\n:::\n\n## Text streams\n\n- Text streams allow for piping of data through a set of applications without writing intermediate files.\n\n::: {.notes}\nWhat I am sure most of you will think of when you read this is the bash pipe sign.\n:::\n\n. . .\n\n`samtools mpileup -uf ref.fa aln.bam | bcftools call -mv | myPythonscript.py | myRscript.R > variants.vcf`\n\n::: {.notes}\nSo how does R handle taking input piped to it. And the answer is that we have to write some special code if this is the use case.\n:::\n\n. . .\n\n### Reading\n\n- To define and open a connection, read one line, and close it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_con  <- file(\"stdin\")\nopen(input_con)\noneline=readLines(input_con, n = 1)\nclose(input_con)\n```\n:::\n\n\n- Tidyverse can read a `tibble` from text stream: `read_csv(file(\"stdin\"))`\n\n::: {.notes}\nWhat we do is **open** a connection from **standard input** and then read this **text stream** for **n** number of lines at a time. It is also good to close this connection afterwards.\n\nAlternatively you can read a text stream into a **tibble** from tidyverse by using **read_csv**, note that it isnt **read.csv** the generic R command, which can take our **input connection** and create the tibble in R.\n:::\n\n## Text streams\n\n#### Writing\n\n- Any `stdout` produced by the code (`print()`, `cat()`, etc) can be piped to a new process: `./myRscript.R | myNewScript`\n\n- or written to a file: `./myRscript.R > output.csv`\n\n- To write a `tibble` as a text stream: `cat(format_csv(my_tibble))`\n\n::: {.notes}\nWhat about **piping from** your R script to something else? Continuing the stream? So just writing these commands. print, cat etc, can be piped to a new process.\n\nIf you already have a tibble, you can stream it out of R using this command.\n:::\n\n## Summary\n\n<!-- ![](http://www.azquotes.com/picture-quotes/quote-this-is-the-unix-philosophy-write-programs-that-do-one-thing-and-do-it-well-write-programs-douglas-mcilroy-81-95-07.jpg) -->\n\n- Functions are great for organizing code and repeating tasks\n- R scripts are great for performing tasks from command line\n- R scripts can be built in different ways to take arguments or text streams\n\n::: {.notes}\n\nSo to summarize, R scripts are powerful tools to solve a specific problem that you define, and often fit well together with other tools. And now you have learned to execute them in different ways, with inputs and outputs and with other programs. All that is left is to actually write the content.\n:::\n\n## {background-image=\"/assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n         _                  \nplatform x86_64-pc-linux-gnu\nos       linux-gnu          \nmajor    4                  \nminor    3.2                \n```\n\n\n:::\n:::\n\n\n[{{< meta current_year >}} • [SciLifeLab](https://www.scilifelab.se/) • [NBIS](https://nbis.se/) • [RaukR](https://nbisweden.github.io/raukr-2024)]{.smaller}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}