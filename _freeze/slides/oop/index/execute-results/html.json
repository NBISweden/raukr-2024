{
  "hash": "9f926833fbdda21a11af63d747b252da",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Object-Oriented Programming Models in R\"\nauthor: \"Marcin Kierczak\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n\n## {visibility=\"hidden\"}\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Object Oriented Programming\n\n- A programming paradigm -- we work with objects.\n- Plato's cave: ideal objects -- classes, reflections -- instances.\n- Reflects many real-life systems -- easy to model things.\n\n. . .\n\n![](assets/oop_concept.png){height=\"400px\"}\n\n## OOP Systems in R\n\n- **S3** -- basic R OOP system,\n- **S4** -- a bit more advanced OOP, common in, e.g. Bioconductor,\n- RC -- Reference Classes, the most advanced and close to, e.g. Java OOP, extension of S4,\n- **R6** -- simplified RC, extension of S3, `require(R6)`\n- **S7** -- best of S3 + S4 = S7 `require(S7)`. Still in dev phase.\n\n## S4 classes\n\nS4 classes are more advanced than S3 as you actually define the structure of the data within the object of your particular class:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# declare class\nsetClass('gene', representation(name='character', coords='numeric'))\n```\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# instantiate class\nmy.gene <- new(\"gene\", name = \"ANK3\", coords = c(1.4e6, 1.412e6))\n```\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# declare class\n.intragenic_region <- setClass(Class = 'intragenic_region', \n                               slots = c(name='character', coords='numeric'))\n\n# instantiate class\n# but since SetClass returns a low-level constructor\nmy.intra1 <- .intragenic_region(name = 'int1', \n                  coords = c(1.7e6, 1.717e6))\n```\n:::\n\n\n\n## Inheritance in S4\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.ext_gene <- setClass(Class = 'ext_gene',contains = \"gene\",\n  slots = c(gene = 'gene', feature_name = 'character', feature_value = 'character')\n)\nANK3 <- .ext_gene(name = 'ANK3', coords = c(1.4e6, 1.412e6),\n                  feature_name = 'num_introns', feature_value = '5')\nstr(ANK3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFormal class 'ext_gene' [package \".GlobalEnv\"] with 5 slots\n  ..@ gene         :Formal class 'gene' [package \".GlobalEnv\"] with 2 slots\n  .. .. ..@ name  : chr(0) \n  .. .. ..@ coords: num(0) \n  ..@ feature_name : chr \"num_introns\"\n  ..@ feature_value: chr \"5\"\n  ..@ name         : chr \"ANK3\"\n  ..@ coords       : num [1:2] 1400000 1412000\n```\n\n\n:::\n:::\n\n\n\n## Sealed Class\n\nPreventing double class definition:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass('Not_Sealed')\nsetClass('Not_Sealed')\n```\n:::\n\n\n\nBut to prevent this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass('Sealed', sealed = T)\nsetClass('Sealed')\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in setClass(\"Sealed\"): \"Sealed\" has a sealed class definition and cannot be redefined\n```\n\n\n:::\n:::\n\n\n\n## S4 class -- slots\n\nThe variables within an S4 class are stored in the so-called **slots**. In the above example, we have 2 such slots: *name* and *coords*. Here is how to access them:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.gene@name # access using @ operator\nmy.gene@coords[2] # access the 2nd element in slot coords\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ANK3\"\n[1] 1412000\n```\n\n\n:::\n:::\n\n\n\n## S4 class -- methods\n\nThe power of classes lies in the fact that they define both the data types in particular slots and operations (functions) we can perform on them. Let us define a *generic print function* for an S4 class:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetMethod('print', 'gene', \n          function(x) {\n              cat('GENE: ', x@name, ' --> ')\n              cat('[', x@coords, ']')\n          })\nprint(my.gene) # and we use the newly defined print\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGENE:  ANK3  --> [ 1400000 1412000 ]\n```\n\n\n:::\n:::\n\n\n\n## S3 Classes\n\nAn S3 class object is one of R base types (e.g. integer) with `class` attribute set:\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobj <- factor(c(\"a\", \"b\", \"c\"))\ntypeof(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"a\" \"b\" \"c\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"a\",\"b\",\"c\": 1 2 3\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(obj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b c\nLevels: a b c\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(unclass(obj))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\nattr(,\"levels\")\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n\n## Custom `str` Methods\n\nSome S3 classes provide a custom `str`, e.g.: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime <- strptime(\"2018-06-07\", \"%Y-%m-%d\")\n```\n:::\n\n\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n POSIXlt[1:1], format: \"2018-06-07\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(unclass(time))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 11\n $ sec   : num 0\n $ min   : int 0\n $ hour  : int 0\n $ mday  : int 7\n $ mon   : int 5\n $ year  : int 118\n $ wday  : int 4\n $ yday  : int 157\n $ isdst : int 1\n $ zone  : chr \"CEST\"\n $ gmtoff: int NA\n - attr(*, \"tzone\")= chr [1:3] \"\" \"CET\" \"CEST\"\n - attr(*, \"balanced\")= logi TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n## Generic Methods and Method Dispatch\n\nHave you ever wondered why `print()` or `summary()` work on many types (classes) of data? \n\n. . .\n\nThey are so-called *generics*, i.e. functions and methods that operate on classes. They know which method to apply to which class thanks to the process of *method dispatch*. \n\nThe naming scheme for generics is: `generic.class()` i.e. a generic that applies to the `class` class. \n\nExamples:\n\n- `print.factor()`, \n- `print.default()`, \n- `print.data.frame()`.\n\nTo see the code of a method:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetS3method('summary', 'lm') %>% \n  head(n = 5)\n```\n:::\n\n\n\n## Creating S3 Classes\n\nTo create an S3 class, simply give a name to a data structure:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngf <- structure(list(), class = 'genomic_features')\nclass(gf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"genomic_features\"\n```\n\n\n:::\n:::\n\n\n\nOR\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngf <- list()\nclass(gf) <- 'genomic_features'\nclass(gf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"genomic_features\"\n```\n\n\n:::\n:::\n\n\n\nYou can use some inheritance too:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\negf <- list()\nclass(egf) <- c('genomic_features', 'extended_genomic_features')\nclass(egf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"genomic_features\"          \"extended_genomic_features\"\n```\n\n\n:::\n:::\n\n\n\n## Checking for Correctness\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinmod <- with(mtcars, lm(log(mpg) ~ log(disp)))\nlinmod\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = log(mpg) ~ log(disp))\n\nCoefficients:\n(Intercept)    log(disp)  \n     5.3810      -0.4586  \n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(linmod) <- \"data.frame\"\nlinmod\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `[<-.data.frame`(`*tmp*`, , j, value = c(`(Intercept)` = 5.3809725, : replacement has 2 rows, data has 0\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n[S C A R Y !]{.large .center}\n\n## Software engineering\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n![Margaret Hamilton, source: Wikimedia Commons](assets/Margaret_Hamilton_-_restoration.jpg){height=\"500px\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](assets/Design-Pattern-GoF-Book.jpg){height=\"500px\"}\n\n:::\n::::\n\n## Design patterns\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![Source: Wikimedia Commons](assets/Door_1.JPG){height=\"400px\"}\n:::\n\n::: {.column width=\"50%\"}\n![Source: Wikimedia Commons](assets/Door_5_CompressionBraceLoads-1.jpg){height=\"400px\"}\n:::\n::::\n\n## R and Design Pattern\n\n- **strategy** &mdash; `apply()`\n- **decorator** &mdash; `system_time()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(x <- runif(n = 100000))\nx[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.002   0.000   0.003 \n[1] 0.3319210 0.7142757 0.6870337 0.5222928 0.4551353\n```\n\n\n:::\n:::\n\n\n\n- **wrapper** \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_plot <- function(...) {\n  plot(..., col = 'blue', las = 1, cex = .5, pch = 19, cex.axis = .7)\n}\n```\n:::\n\n\n\n- **Singleton** [see this gist](https://gist.github.com/jverzani/1953641)\n- **Fluent function interface** &mdash; `tidyverse` functions take data `x` as the very first argument and return object similar to `x` so that they can be chained by `%>%`\n\nEven more patterns [here](https://github.com/tidylab/R6P).\n\n## Safe S3 Design Pattern -- Constructor \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_Animal <- function(species, age) {\n  stopifnot(is.character(species))\n  stopifnot(is.numeric(age))\n  \n  structure(\n    species,\n    age = age,\n    class = \"Animal\"\n  )\n}\n```\n:::\n\n\n\n## Safe S3 Design Pattern -- Validator \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalidate_Animal <- function(x) {\n  species <- x[1]\n  age <- attr(x, 'age')\n  \n  if (is.na(species) || species == \"\") {\n    stop('Species name is missing!', call. = FALSE)\n  }\n  if (!is.numeric(age) || age < 1 || age >= 100) {\n    stop(\"Invalid age!\", call. = FALSE)\n  }\n  return(x)\n}\n```\n:::\n\n\n\n## Safe S3 Design Pattern -- Helper\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAnimal <- function(x) {\n  species <- x[[1]] \n  age <- x[[2]]\n  validate_Animal(new_Animal(species, age))\n}\n```\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog <- Animal(list('Canis familiaris', 7))\nclass(dog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Animal\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat <- Animal(list('Felis felis', '9'))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in new_Animal(species, age): is.numeric(age) is not TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncat <- Animal(list('Felis felis', 9))\nclass(cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Animal\"\n```\n\n\n:::\n:::\n\n\n\n## Building S3 Classes -- Styles\n\nOne can build an S3 class on top of any existing base type, e.g. a named list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint_in_space_class <- function(x, y, z) {\n  structure(\n    list(\n      x = x, \n      y = y, \n      z = z\n    ),\n    class = \"point_in_space_class\"\n  )\n}\n```\n:::\n\n\n\n## Introduction to R6 classes\n\n- `require(R6)`,\n- Do not rely on S4 like RC, but on S3,\n- Are faster than RC,\n- Do not do *copy-on-modify*,\n- Thus provide OO model similar to C++ or Java.\n- Methods belong to objects, not to generics.\n\n## R6 Class Example\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|3-4|5-6|6-11|13-14|15-17\"}\nlibrary(R6)\n\nPerson <- R6Class(\"Person\",\n  public = list(\n    name = NULL,\n    hair = NULL,\n    initialize = function(name = NA, hair = NA) {\n      stopifnot(is.character(name), is.character(hair))\n      self$name <- name\n      self$hair <- hair\n      self$greet()\n    },\n    set_hair = function(val) {\n      self$hair <- val\n    },\n    greet = function() {\n      cat(paste0(\"Hello, my name is \", self$name, \".\\n\"))\n    }\n  )\n)\n```\n:::\n\n\n\n## R6 in Action\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkate <- Person$new(name = 'Kate', hair = 'blond')\nstr(kate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello, my name is Kate.\nClasses 'Person', 'R6' <Person>\n  Public:\n    clone: function (deep = FALSE) \n    greet: function () \n    hair: blond\n    initialize: function (name = NA, hair = NA) \n    name: Kate\n    set_hair: function (val)  \n```\n\n\n:::\n:::\n\n\n\n## R6 -- methods\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkate$greet()\nkate$set_hair('red')\nkate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHello, my name is Kate.\n<Person>\n  Public:\n    clone: function (deep = FALSE) \n    greet: function () \n    hair: red\n    initialize: function (name = NA, hair = NA) \n    name: Kate\n    set_hair: function (val) \n```\n\n\n:::\n:::\n\n\n\n## R6 copy-on-modify\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkate$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"red\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nann <- kate\nann$set_hair('blue')\nann$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkate$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"blue\"\n```\n\n\n:::\n:::\n\n\n\n## R6 -- clone()\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkate$set_hair('brown')\nkate$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"brown\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2-3\"}\nann <- kate$clone()\nkate$hair\nann$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"brown\"\n[1] \"brown\"\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nann$set_hair('blond')\nkate$hair\nann$hair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"brown\"\n[1] \"blond\"\n```\n\n\n:::\n:::\n\n\n\n## {background-image=\"/assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n         _                    \nplatform x86_64-apple-darwin20\nos       darwin20             \nmajor    4                    \nminor    4.0                  \n```\n\n\n:::\n:::\n\n\n\n[{{< meta current_year >}} • [SciLifeLab](https://www.scilifelab.se/) • [NBIS](https://nbis.se/) • [RaukR](https://nbisweden.github.io/raukr-2024)]{.smaller}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}