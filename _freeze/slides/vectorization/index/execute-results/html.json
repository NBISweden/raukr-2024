{
  "hash": "0d2cecfde1a4742d858506eed0b6feb1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectorization in R\"\nauthor: \"Marcin Kierczak\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n## {visibility=\"hidden\"}\n\n\n::: {.cell}\n\n:::\n\n\n## Learning Outcomes\n\nBy the end of this module, you will:\n\n- understand how to write more efficient loops\n- be able to vectorize most loops\n- understand how the `apply*` functions work\n- be aware of the `purrr` package\n- understand what a recursive call is\n\n## The simplest of all `for` loops\n\nSay, we want to add 1 to every element of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:5)\nvec\nfor (i in vec) {\n  vec[i] <- vec[i] + 1\n}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n[1] 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\n. . .\n\nExactly the same can be achieved in R by means of **vectorization**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:5)\nvec + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5 6\n```\n\n\n:::\n:::\n\n\nWhich is better? ðŸ˜•\n\n## Repeating actions &mdash; vectorization\n\nLet us compare the time of execution of the vectorized version (vector with 10,000 elements):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:1e6)\npeakRAM::peakRAM(vec <- vec + 1)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Function_Call | Elapsed_Time_sec| Total_RAM_Used_MiB| Peak_RAM_Used_MiB|\n|:-------------|----------------:|------------------:|-----------------:|\n|vec<-vec+1    |            0.003|                3.9|               7.7|\n\n</div>\n:::\n:::\n\n\n. . .\n\nto the loop version:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:1e6)\nloop <- function(vec) {\n  for (i in vec) {\n    vec[i] <- vec[i] + 1\n  }\n  return(vec)\n}\npeakRAM::peakRAM(loop(vec))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Function_Call | Elapsed_Time_sec| Total_RAM_Used_MiB| Peak_RAM_Used_MiB|\n|:-------------|----------------:|------------------:|-----------------:|\n|loop(vec)     |            0.201|                7.6|               7.7|\n\n</div>\n:::\n:::\n\n\n## Vectorization &mdash; the problem\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_a_droid <- function(x) {\n  droids <- c('2-1B', '4-LOM', '8D8', '0-0-0', 'AP-5', 'AZI-3', 'Mister Bones', 'BB-8', 'BB-9E', 'BD-1', 'BT-1', 'C1-10P', 'C-3PO', 'R2-D2')\n  if (x %in% droids) {\n    return(T)\n  } else {\n    return(F)\n  }\n}\n\ntest <- c('Anakin', 'Vader', 'R2-D2', 'AZI-3', 'Luke')\nis_a_droid(test)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in if (x %in% droids) {: the condition has length > 1\n```\n\n\n:::\n:::\n\n\n## Vectorization &mdash; the solution(s)\n\nThe `base::Vectorize` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvectorized_is_a_droid <- base::Vectorize(is_a_droid, vectorize.args = c('x'))\nvectorized_is_a_droid(test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \n```\n\n\n:::\n:::\n\n\n. . .\n\nThe `apply*` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(as.matrix(test), FUN = is_a_droid, MARGIN = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(test, FUN=is_a_droid) %>% unlist() # list apply\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(test, is_a_droid) # simplified lapply\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \n```\n\n\n:::\n:::\n\n\n## Vectorization &mdash; the solution(s)\n\nThe `vapply`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = TRUE) # value type-safe sapply \nvapply(test, is_a_droid, FUN.VALUE = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \nAnakin  Vader  R2-D2  AZI-3   Luke \n     0      0      1      1      0 \n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = 'a')\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in vapply(test, is_a_droid, FUN.VALUE = \"a\"): values must be type 'character',\n but FUN(X[[1]]) result is type 'logical'\n```\n\n\n:::\n:::\n\n\n. . .\n\nOr the `purrr` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(test, is_a_droid) %>% unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n## Recursion\n\nWhen we explicitly repeat an action using a loop, we talk about **iteration**. We can also repeat actions by means of **recursion**, i.e. when a function calls itself. Let us implement a factorial $!$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial_rec <- function(x) {\n  if (x == 0 || x == 1)\n    return(1)\n  else\n    return(x * factorial_rec(x - 1)) # Recursive call!\n}\nfactorial_rec(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n:::\n\n\n## To recurse or to iterate?\n\n    Comparing recursion to iteration is like comparing a phillips head screwdriver to a flat head screwdriver. For the most part you could remove any phillips head screw with a flat head, but it would just be easier if you used the screwdriver designed for that screw right?\n\n    Some algorithms just lend themselves to recursion because of the way they are designed (Fibonacci sequences, traversing a tree like structure, etc.). Recursion makes the algorithm more succinct and easier to understand (therefore shareable and reusable)\n\n -- [StackOverflow](https://stackoverflow.com/questions/72209/recursion-or-iteration)\n \n## Loops &mdash; avoid growing data\n\nAvoid changing dimensions of an object inside the loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c() # Initialize\nfor (i in 1:100) {\n  v <- c(v, i)\n}\n```\n:::\n\n\n. . .\n\nIt is much better to do it like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- rep(NA, 100) # Initialize with length\nfor (i in 1:100) {\n  v[i] <- i\n}\n```\n:::\n\n\n## {background-image=\"/assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n         _                  \nplatform x86_64-pc-linux-gnu\nos       linux-gnu          \nmajor    4                  \nminor    3.2                \n```\n\n\n:::\n:::\n\n\n[{{< meta current_year >}} â€¢ [SciLifeLab](https://www.scilifelab.se/) â€¢ [NBIS](https://nbis.se/) â€¢ [RaukR](https://nbisweden.github.io/raukr-2024)]{.smaller}\n\n## Recursion = iteration?\n\nYes, every iteration can be converted to recursion (Church-Turing conjecture) and *vice versa*. It is not always obvious, but theoretically it is doable. Let's see how to implement *factorial* in iterative manner:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial_iter <- function(x) {\n  if (x == 0 || x == 1)\n    return(1)\n  else {\n    tmp <- 1\n    for (i in 2:x) {\n      tmp <- tmp * i\n    }\n    return(tmp)  \n  }\n}\nfactorial_iter(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n:::\n\n\n## Recursion == iteration, really?\n\nMore writing for the iterative version, right? What about the time efficiency?  \nThe recursive version:\n\n::: {.cell}\n\n```{.r .cell-code}\npeakRAM::peakRAM(factorial_rec(1000))\n```\n:::\n\n\nAnd the iterative one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeakRAM::peakRAM(factorial_iter(1000))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Function_Call        | Elapsed_Time_sec| Total_RAM_Used_MiB| Peak_RAM_Used_MiB|\n|:--------------------|----------------:|------------------:|-----------------:|\n|factorial_iter(1000) |            0.005|                  0|               0.1|\n\n</div>\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}