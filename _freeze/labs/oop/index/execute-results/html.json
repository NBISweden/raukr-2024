{
  "hash": "84f75cd7c7f4a5d49a583a8a84241595",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Object-Oriented Programming in R\"\nauthor: \"Marcin Kierczak\"\ndescription: \"Class systems in the R language.\"\nimage: \"assets/featured.jpg\"\nformat: html\n---\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-note}\nDuring this lab, we will go through the most important features of 3 out of the 4 existing OOP systems in R:\n\n- S3,\n- S4,\n- R6.\n\nWhile S3 and S4 are base-R OOP systems, R6 is provided by the `R6` package. Both S3 and S4 follow the *functional OOP style* while `R6` is more similar to OOP models known from Java or C++. We will not cover the Reference Classes (a.k.a. RC) which is yet another base-R OOP model. Why? Well, it is really tricky to use and its documentation is not always complete...\n:::\n\n## S3 Classes\n\n- What is the class of the object returned by the `lm()` function?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nobj <- lm(speed ~ dist, data = cars) \nclass(obj)\n```\n:::\n\n\n- What basic data type is it build upon?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntypeof(obj)\n```\n:::\n\n\n- What attributes does the object of the `lm` class have?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nattributes(obj)\n```\n:::\n\n\n- What is the structure of the `lm` object?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\n```\n:::\n\n\n- Does the `lm` class implement own `str()`?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\n# compare to:\nstr(unclass(obj)) \n\n# Answer: no\n```\n:::\n\n\n- What is the class of a `tibble`? You have to load the `tidyverse` package and use on of the built-in datasets, e.g. `mtcars` as argument to `as_tibble()` to check the class.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrequire(tidyverse)\nobj <- as_tibble(mtcars)\nclass(obj)\n```\n:::\n\n\n- What is the underlying data type?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntypeof(obj)\n```\n:::\n\n\n- Is the `str()` function used by tibbles the default `str()`?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\nstr(unclass(obj))\n# Answer: no\n```\n:::\n\n\n- Implement your own class `meta_frame` that is a `data.frame` with additional attributes:\n  - Character attribute `descr` (a description),\n  - `creation` attribute which will hold the creation date.\n\nCheck that it works, i.e. that it has the expected attributes and that it is a separate class.\n\n- How do you access the `description` field?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmeta_frame <- function(df, descr, creation) {\n  structure(\n    list(\n      df = df, \n      descr = descr, \n      creation = creation\n    ),\n    class = \"meta_frame\"\n  )\n}\nobj <- meta_frame(mtcars, 'The mtcars dataset', '10-06-2018')\nstr(obj)\nobj$descr\n```\n:::\n\n\n- Design implementation of your own S3 class `protein` that stores the following information (you will implement the class in the next point, now just think and draw on paper if you wish):\n  - Protein sequence,\n  - Protein length,\n  - Post-translational modification (PTM) site coords,\n  - PTM type that can be either of: \"phosphorylation\", or \"methylation\".\n    \n- Implement the `protein` class from the previous point using the *constructor, validator and helper* design pattern. Try to reduce the number of input arguments to: +     + a sequence and \n  - A list of PTMs.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Constructor\nnew_protein <- function(sequence, length, ptm_site, ptm_type) {\n  stopifnot(is.character(sequence))\n  stopifnot(is.integer(length))\n  stopifnot(is.numeric(ptm_site))\n  stopifnot(is.character(ptm_type))\n  structure(\n    sequence,\n    length = length,\n    ptm_site = ptm_site,\n    ptm_type = ptm_type,\n    class = \"protein\"\n  )\n}\n\n# Helper\nprotein <- function(sequence, ptm) {\n  sequence <- sequence\n  len <- nchar(sequence)\n  ptm_site <- ptm[[1]]\n  ptm_type = ptm[[2]]\n  validate_protein(new_protein(sequence, len, ptm_site, ptm_type))\n}\n\n# Validator\nvalidate_protein <- function(x) {\n  sequence <- x[1]\n  len <- attr(x, 'length')\n  ptm_site <- attr(x, 'ptm_site')\n  ptm_type <- attr(x, 'ptm_type')\n  if (is.na(sequence)) {\n    stop('Sequence is missing!', call. = FALSE)\n  }\n  if (length(ptm_site) != length(ptm_type)) {\n    stop('PTM type and site differ in length!', call. = FALSE)\n  }\n  if ((sum(!ptm_type %in% c('phosphorylation', 'methylation'))) > 0) {\n    stop('Invalid PTM types detected!', call. = FALSE)\n  }\n  return(x)\n}\n```\n:::\n\n\n- What would you improve in our implementation of `protein`. Is it really user friendly?\n- Write a generic `print` for the `protein` class. It should print e.g.:\n\n```         \n[1] \"============== Protein ==============\"\n[1] \"Sequence:ARNDKLLQWYTTARD\"\n[1] \"Length: 15 aa.\"\n[1] \"============== PTM section ==============\"\n[1] \"Site: 3\" \"Site: 5\"\n[1] \"Type: phosphorylation\" \"Type: methylation\"  \n```\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nprint.protein <- function(x) {\n  sequence <- unclass(x)\n  len <- attr(x, 'length')\n  ptm_site <- attr(x, 'ptm_site')\n  ptm_type <- attr(x, 'ptm_type')\n  print(\"============== Protein ==============\")\n  print(paste0(\"Sequence:\", sequence))\n  print(paste0(\"Length: \", len, \" aa.\"))\n  print(\"============== PTM section ==============\")\n  print(paste0(\"Site: \", ptm_site))\n  print(paste0(\"Type: \", ptm_type))\n}\n```\n:::\n\n\n- Test that the `protein` class works as it should and that generic `print` works as well.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_prot <- protein(\"ARNDKLLQWYTTARD\", \n                   list(\n                     site = c(3, 5), \n                     type = c('phosphorylation', 'methylation')\n                    )\n                  )\nclass(my_prot)\ntypeof(my_prot)\nprint(my_prot)\n```\n:::\n\n\n## S4 Classes\n\n- Re-write the `protein` class in S4 (with validation!).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Generator\n.protein <- setClass('protein',\n                     slots = c(\n                       sequence = 'character',\n                       length = 'numeric',\n                       ptm_site = 'numeric',\n                       ptm_type = 'character'\n                      )\n                    )\n\n# Constructor\nprotein <- function(sequence, ptm) {\n  sequence <- sequence\n  len <- nchar(sequence)\n  ptm_site <- ptm[[1]]\n  ptm_type <- ptm[[2]]\n  if (is.na(sequence)) {\n    stop('Sequence is missing!', call. = FALSE)\n  }\n  if (length(ptm_site) != length(ptm_type)) {\n    stop('PTM type and site differ in length!', call. = FALSE)\n  }\n  if ((sum(!ptm_type %in% c('phosphorylation', 'methylation'))) > 0) {\n    stop('Invalid PTM types detected!', call. = FALSE)\n  }\n  pt <- .protein(sequence = sequence, \n           length = len, \n           ptm_site = ptm_site, \n           ptm_type = ptm_type)\n  return(pt)\n}\n```\n:::\n\n\n- Create an S4 object of the `protein` class and check whether it works.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_prot <- protein(\"ARNDKLLQWYTTARD\", \n                   list(\n                     site = c(3, 5), \n                     type = c('phosphorylation', 'methylation')\n                    )\n                  )\nclass(my_prot)\ntypeof(my_prot)\nstr(my_prot)\n```\n:::\n\n\n- Implement the generic `print` using S4 and check that it works.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsetMethod('print', 'protein', \n  function(x) {\n    sequence <- x@sequence\n    len <- x@length\n    ptm_site <- x@ptm_site\n    ptm_type <- x@ptm_type\n    print(\"============== Protein ==============\")\n    print(paste0(\"Sequence:\", sequence))\n    print(paste0(\"Length: \", len, \" aa.\"))\n    print(\"============== PTM section ==============\")\n    print(paste0(\"Site: \", ptm_site))\n    print(paste0(\"Type: \", ptm_type))\n})\n\nprint(my_prot)\n```\n:::\n\n\n- Implement a new S4 class `ext_protein` that extends `protein` with 3 slots: \n  - Feature type,\n  - Feature position, and\n  - Feature value.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n.ext_protein <- setClass('ext_protein', \n                         contains = c('protein'),\n                         slots = c(\n                           prot = 'protein',\n                           feature_type = 'character',\n                           feature_position = 'numeric',\n                           feature_value = 'character'\n                         ))\nmy_ext_prot <- .ext_protein(prot = my_prot,\n                           feature_type = 'modification',\n                           feature_position = 11,\n                           feature_value = 'absent'\n                  )\nclass(my_ext_prot)\ntypeof(my_ext_prot)\nstr(my_ext_prot)\n```\n:::\n\n\n## R6 Classes\n\n- Install and load the `R6` package,\n- Implement the `protein` class using R6 model and check that it works as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrequire(R6)\nprotein <- R6Class(classname = 'protein',\n                        public = list(\n                          seq = NA,\n                          length = NULL,\n                          ptm_site = NA,\n                          ptm_type = NA,\n                          initialize = function(seq = NA, ptm = NA) {\n                            self$seq <- seq\n                            self$length <- nchar(self$seq)\n                            self$ptm_site <- ptm[[1]]\n                            self$ptm_type <- ptm[[2]]\n                            # Check types\n                            stopifnot(is.character(seq))\n                            \n                            #Validate\n                            if (is.na(self$seq)) {\n                              stop('Sequence is missing!', call. = FALSE)\n                            }\n                            if (length(self$ptm_site) != length(self$ptm_type)) {\n                              stop('PTM type and site differ in length!', call. = FALSE)\n                            }\n                            if ((sum(!self$ptm_type %in% c('phosphorylation', 'methylation'))) > 0) {\n    stop('Invalid PTM types detected!', call. = FALSE)\n  }\n                          }\n )\n)\n\nmy_new_prot <- protein$new(seq = \"ARNDKLLQWYTTARD\", ptm = \n                   list(\n                     site = c(3, 5), \n                     type = c('phosphorylation', 'methylation')\n                    ))\nstr(my_new_prot)\n```\n:::\n\n\n**Congratulations! You are familiar with S3, S4 and R6 object models by now!**\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}